# 设计模式原则之单一职责原则 SRP

## 定义

> 应该有且仅有一个原因引起类的变更。通俗点说，就是一个类负责一项职责。

## 问题

> 假设类 C 负责两项不同的职责：职责 P1 和职责 P2。当职责 P1 因需求发生改变而需要修改类 C 时，就有可能导致职责 P2 的功能也受到影响。

## 解决方案

分别建立两个类 C1、C2，使得 C1 负责职责 P1，C2 负责职责 P2。这样，当修改类 C1 时，职责 P2 不会受到影响；同理，修改类 C2 时，也不会使职责 P1 受到影响。

## 实践

在日常开发中，不论是新手还是经验丰富的程序员，都有可能因一些不确定的因素导致违背单一职责原则。这主要是因为存在**职责扩散**。所谓**职责扩散**，是指**因为某种原因，职责 P 需要被划分为粒度更小更细的职责 P1 和 P2**。

举个实例来说明一下，用一个类描述枪可以射击杀人的场景：

```java
/**
 * 枪类
 */
public class Gun {
    public void shoot(String gun) {
        System.out.println(gun + "可以射击杀人");
    }
}
```

```java
/**
 * 场景类
 */
public class Client {
    public static void main(String[] args) {
        Gun gun = new Gun();
        gun.shoot("手枪");
        gun.shoot("步枪");
        gun.shoot("机枪");
    }
}
```

执行结果：

> 手枪可以射击杀人
> 步枪可以射击杀人
> 机枪可以射击杀人

项目完成后，发现是存在问题的，并不是所有的枪都可以杀人，例如玩具枪就杀不了人。这种情况下，如果要遵守**单一职责**原则，那么就需要将**Gun**类细分为真枪 RealGun 和玩具枪 ToyGun，代码如下：

```java
/**
 * 真枪类
 */
public class RealGun {
    public void shoot(String gun) {
        System.out.println(gun + "可以杀人");
    }
}
```

```java
/**
 * 玩具枪
 */
public class ToyGun {
    public void shoot(String gun) {
        System.out.println(gun + "不能杀人");
    }
}

public class Client {
    public static void main(String[] args) {
        RealGun gun = new RealGun();
        gun.shoot("手枪");
        gun.shoot("步枪");
        gun.shoot("机枪");

        ToyGun toyGun = new ToyGun();
        toyGun.shoot(“玩具枪");
    }
}
```

运行结果：

> 手枪可以杀人
> 步枪可以杀人
> 机枪可以杀人
> 水枪不能杀人

我们发现如上修改代码，的确做到了遵守单一职责原则，只是改动比较费劲，除了分解原来的类之外，还要修改客户端的代码。我们还可以直接修改 Gun 类实现这个需求：

```java
public class Gun {
    public void shoot(String gun) {
        if (“玩具枪".equals(gun)) {
            System.out.println(gun + "不能杀人");
        } else {
            System.out.println(gun + "可以射击杀人");
        }
    }
}
```

这种改动非常简单方便，但是它违背了单一职责原则，存在着一定的隐患。假如有一天需要将玩具枪划分为**木枪**和**水枪**，那还是得修改**Gun**类的 shoot()方法，这样还是会对调用“真枪”的功能产生影响。我们再看另外一种修改方式：

```java
public class Gun {
    public void shoot(String gun) {
        System.out.println(gun + "可以射击杀人");
    }

    public void anotherShoot(String gun) {
        System.out.println(gun + "不能杀人");
    }
}

public class Client {
    public static void main(String[] args) {
        Gun gun = new Gun();
        gun.shoot("手枪");
        gun.shoot("步枪");
        gun.shoot("机枪");

        gun.anotherShoot("水枪");
    }
}
```

如上，这种方式是在类中新增了一个方法来专门处理另一种职责。虽然这也违背了**类**的单一职责原则，但是在**方法**级别上却是符合单一职责原则的。

以上三种方式各有优缺点，具体采用哪种方式，需要具体场景具体对待，但是可以遵守这样一个简单的原则：

> 只有逻辑足够简单，才可以在代码级别上违反**单一职责原则**；只有类中方法数量足够少，才可以在方法级别上违反**单一职责原则**。
> 对于**单一职责原则**，接口在设计时一定要做到单一职责，而类的设计尽量做到只有一个原因引起变化。
